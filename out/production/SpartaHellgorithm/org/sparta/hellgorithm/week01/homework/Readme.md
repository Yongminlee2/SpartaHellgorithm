#시간복잡도란?
특정 연산과정이 수행하는데 걸리는 시간을 의미한다.<br>
알고리즘에 의해 수행되는 기본 연산의 개수를 세어서 예측이 가능하다.

<h3>시간 복잡도 종류</h3>
1.BIG-O:최악의 경우<br>
2.Omega:최상의 경우<br>
3.Theta:평균의 경우<br>
와 같이 3가지 종류로 되어있지만 일반적으로는 Big-O 표기법을 사용한다.

<h3>시간복잡도 표기법</h3>
Big-O : O(N)<br>
알고리즘에서 worst case 실행 시간을 의미한다. <br>
빅오 표기법은 최고차항을 제외한 모든 항과 최고차항의 계수를 제외시킨다.
T(n)=2n^2+n+1일 경우 O(n^2)이다.

```
for(int i=0; i<n; i++){ <br>
        if(a[i]==4) <br>
        break; <br>
}
```
위의 코드는 n번을 다 안돌더라도 a[i]가 없는 경우를 생각하면 n번 돌기때문에 O(N)의 시간복잡도를 가진다. <br>

```
printf("hello")
```
또한 위와같이 입력값과 관계가 없을 경우에는 상수값을 가지게되어 O(1)이라고 표현한다.

정리하자면 다음과 같다.

**하나의 루프를 사용하여 단일 요소 집합을 반복하는 경우: O(n)** <br>
**컬렉션의 절반 이상을 반복하는 경우:O(n/2) -> O(n)** <br>
**두개의 다른 루프를 사용하여 두개의 개별 콜렉션을 반복할 경우: O(n+m)=O(n)** <br>
**두개의 중첩 루프를 사용하여 단일 컬렉션을 반복하는 경우:O(n^2)** <br>
**두개의 중첩루프를 사용하여 두개의 다른 컬렉션을 반복하는 경우:O(n X m) -> O(n^2)** <br>
**컬렉션 정렬을 사용하는 경우(ex. 이진정렬): O(n X log(n))** <br>

<hr>

#공간복잡도
특정 연산과정중에 얼마나 많은 저장공간이 필요한지를 의미한다.
공간복잡도도 시간복잡도와 같이 빅오표기법으로 표시한다. <br>
S(p) = c + Sp(n) <br>
총 저장공간 = 고정 공간 + 가변 공간<br>
공간복잡도 상으로는 고정 공간보다는 가변공간을 사용할 수 있는 자료구조들이 더 효율적이다. <br>
특히 재귀함수의 경우에 매 함수 호출마다 매개변수,지역변수, 함수의 복귀 주소를 저장할 공간이 필요하기때문에 
반복문으로 짤수 있는 경우에는 반복문으로 짜는게 더 효율적이다.<BR>

```
int sum(int a[], int n)
{
  int x = 0;		
  for(int i = 0; i < n; i++) {
    x  = x + a[i];
  }
  return(x);
}
```
위의 코드는 4개의 변수를 사용하고 있다.<br>
int arr[n] : 4*n byte<br>
int n: 4 bytes <br>
int x: 4 bytes <br>
int i: 4bytes <br>
총 4n+12의 메모리를 요구한다. 빅오로 표기하면 O(n)이다.
<hr>

#BinarySearch
<h3>입력 데이터</h3>: N

<h3>시간복잡도</h3>
이진탐색 = N개의 데이터를 반으로 나누면서 계산을 하여서 O(logN)<br>
출력 = N개의 데이터를 전부 순회하면서 출력 N 2회 반복하여서 O(2*N)<br>
이진탐색을 하는 과정내에서 출력을 매번하게되니 총합 시간복잡도는 O(logN)*O(N)=O(logN * N)=> O(NlogN)

<h3>공간복잡도</h3>
입력데이터가 N개이고 입력데이터 말고 추가 선언하는 메모리가 없기때문에 O(n)이다.<br>

