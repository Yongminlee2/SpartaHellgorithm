칵테일 정렬 틀렸으니 다시 확인 후 수정하세요. 수정내용에 뭐가 잘못된건지 주석 달아놓으세요.



#### 단순 선택 정렬

단순 선택 정렬은 가장 작은 요소부터 선택해 알맞은 위치로 옮겨서 순서대로 정렬하는 알고리즘이다.



아래의 배열을 보자.

아 알고리즘은 가장 작은 요소부터 정렬하는 알고리즘이기 때문에 가장 작은 값의 요소인 1을 선택해 정렬을 시작한다.



| 6    | 4    | 8    | 3    | 1    | 9    | 7    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |

첫 번째로 1과 6을 교환한다. 교환한 다음의 배열은 아래와 같다.

| 1    | 4    | 8    | 3    | 6    | 9    | 7    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |

가장 작은 요소인 1이 맨 앞으로 왔다. 이어서 두 번째로 작은 요소인 3을 선택해 정렬한다. 3을 4와 교환하면 아래처럼 두 번째 요소의 정렬이 끝난다.

| 1    | 3    | 8    | 4    | 6    | 9    | 7    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |

다음으로 세 번째 작은 요소인 4을 선택해 8과 4을 교환한다. 이후의 배열은 다음과 같다.

| 1    | 3    | 4    | 8    | 6    | 9    | 7    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |

단순 선택 정렬의 교환 과정은 아래와 같다.

1. 아직 정렬하지 않은 부분에서 가장 작은 키의 값(a[min]) 을 선택한다.
2. a[min]과 아직 정렬하지 않은 부분의 첫번째 요소를 교환한다.



SelectionSort 예제 참조.

단순 선택 정렬 알고리즘의 요솟값을 비교하는 횟수는 (n^2-n)/2회 이다. 

그런데 이 정렬알고리즘은 서로 떨어져 있는 요소를 교환하는 것이기 때문에 안정적이지 않다.



#### 단순 삽입 정렬

단순 삽입 정렬은 선택한 요소를 그보다 더 앞쪽의 알맞은 위치에 '삽입하는' 작업을 반복하여 정렬하는 알고리즘이다. 단순 선택 정렬과 비슷하게 보일 수 있지만 단순 선택 정렬은 값이 가장 작은 요소를 선택해 알맞은 위치로 옮긴다는 점이 다르다.



단순 삽입 정렬은 트럼프 카드를 한 줄로 늘어놓을 때 사용하는 방법과 비슷한 방법의 알고리즘이다.

아래의 배열을 예로 들어보자.

| 6    | 4    | 1    | 7    | 3    | 9    | 8    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |

단순 삽입 정렬은 2번째 요소부터 선택하여 진행한다. 이때 4는 6부터 앞쪽에 위치해야 하므로 앞쪽에 삽입한다.

이 상태에서 6을 오른쪽으로 밀면 아래처럼 된다.

| 4    | 6    | 1    | 7    | 3    | 9    | 8    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |

다음으로 3번째 요소인 1을 선택해 앞쪽에 삽입한다.  

| 1    | 4    | 6    | 7    | 3    | 9    | 8    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |

그다음은 7, 3 등 계속해서 같은 작업을 수행하며 이 작업을 n-1회 반복해야 정렬을 마친다.



**단순 삽입 정렬은 아직 정렬되지 않은 부분의 첫 번째 요소를 정렬된 부분의 알맞은 위치에 삽입하는 것이다.**



단순삽입 정렬 예시 참조.

단순 삽입 정렬은 셔틀 정렬이라고도 불리우며,  떨어져있는 요소들이 서로 뒤바뀌지 않아 안정적이다.

요소의 비교 횟수와 교환 횟수는 n^2/2 회이다.



#### 단순 정렬의 시간복잡도

지금 까지 공부한 세가지 단순 정렬(버블, 선택, 삽입) 의 시간 복잡도는 모두 O(N^2)이다. 



##### **문제 1. 단순 삽입 정렬에서 배열의 첫 번째 요소(a[0])부터 데이터를 저장하지 않고, a[1]부터 데이터를 저장하면 a[0]을 보초로 하여 삽입을 마치는 조건을 줄일 수 있다.**

**이아이디어를 적용한 단순 삽입 정렬 메소드를 수정하라.**





**문제2. 단순 삽입 정렬은 배열의 요솟수가 많아지면 많아질수록 요소 삽입에 필요한 대교, 대입 비용이 무시할 수 없을 정도로 커진다. 이때 배열에서 이미 정렬된 부분은 이진 검색을 사요할 수 있기 때문에 삽입할 위치를 더 빨리 찾을 수 있다. 이진 검색을 사용하여 프로그램을 수정하라.**



#### 셸 정렬



셸 정렬은 단순 삽입 정렬의 장점은 살리고 단점은 보완하여 좀 더 빠르게 정렬하는 알고리즘이다.



단순 산입 정렬의 특징

* 정렬을 마쳤거나 정렬을 마친 상태에 가까우면 정렬 속도가 매우 빨라진다 (장점)
* 삽입할 위치가 멀리 떨어져 있으면 대입(이동) 해야하는 횟수가 많아진다. (단점)



먼저 셸 정렬은 정렬할 배열의 요소를 그룹으로 나눠 각 그룹별로 단순 삽입 정렬을 수행하고, 그 그룹을 합치면서 정렬을 반복하여 요소의 이동 횟수를 줄이는 방법이다.

아래의 배열을 예로 들어 살펴보자.



| 8    | 1    | 4    | 2    | 7    | 6    | 3    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

먼저 배열을 4개의 그룹 ({8,7}, {1,6},{4,3},{2,5})으로 나누고 각 그룹별로 정렬한다.

1그룹은 {8,7}을 정렬하여 {7,8}로 2그룹은 {1,6}로 정렬하여 {1,6}으로, 3그룹은 {4,3}을 정렬하여 {3,4}로, 4그룹은 {2,5}를 정렬하여 {2,5}로 정렬된 상태이다.



이렇게 4칸만큼 떨어진 요소를 모아 그룹을 4개로 나누어 정렬하는 방법을 '4-정렬'이라고 한다.

아직 정렬을 마친 상태는 아니지만 정렬을 마친 상태에 가까워진다.

**1그룹**

| <span style="color:red;">8</span> | 1    | 4    | 2    | <span style="color:red;">7</span> | 6    | 3    | 5    |
| --------------------------------- | ---- | ---- | ---- | --------------------------------- | ---- | ---- | ---- |

| <span style="color:red;">7</span> | 1    | 4    | 2    | <span style="color:red;">8</span> | 6    | 3    | 5    |
| --------------------------------- | ---- | ---- | ---- | --------------------------------- | ---- | ---- | ---- |

**2그룹**

| 7    | <span style="color:red">1</span> | 4    | 2    | 8    | <span style="color:red">6</span> | 3    | 5    |
| ---- | -------------------------------- | ---- | ---- | ---- | -------------------------------- | ---- | ---- |

| 7    | <span style="color:red">1</span> | 4    | 2    | 8    | <span style="color:red">6</span> | 3    | 5    |
| ---- | -------------------------------- | ---- | ---- | ---- | -------------------------------- | ---- | ---- |

**3그룹**

| 7    | 1    | <span style="color:red">4</span> | 2    | 8    | 6    | <span style="color:red">3</span> | 5    |
| ---- | ---- | -------------------------------- | ---- | ---- | ---- | -------------------------------- | ---- |

| 7    | 1    | <span style="color:red">3</span> | 2    | 8    | 6    | <span style="color:red">4</span> | 5    |
| ---- | ---- | -------------------------------- | ---- | ---- | ---- | -------------------------------- | ---- |

**4그룹**

| 7    | 1    | 3    | <span style="color:red;">2</span> | 8    | 6    | 4    | <span style="color:red;">5</span> |
| ---- | ---- | ---- | --------------------------------- | ---- | ---- | ---- | --------------------------------- |

| 7    | 1    | 3    | <span style="color:red;">2</span> | 8    | 6    | 4    | <span style="color:red;">5</span> |
| ---- | ---- | ---- | --------------------------------- | ---- | ---- | ---- | --------------------------------- |





정렬을 마치지는 않았지만 정렬을 마친 상태에 가까워졌다.

| 7    | 1    | 3    | 2    | 8    | 6    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |



다음은 4-정렬을 마친 상태에서 2칸만큼 떨어진 요소를 모아 두 그룹으로 나누어 정렬하는 '2-정렬'의 과정이다.

({7,3,8,4}, {1,2,6,5})로 그룹지었다.

정렬을 마치고 나면 각각의 그룹은 {3,4,7,8}, {1,2,5,6}으로 정ㅇ렬된다.

**1그룹**

| <span style="color:red;">7</span> | 1    | <span style="color:red;">3</span> | 2    | <span style="color:red;">8</span> | 6    | <span style="color:red;">4</span> | 5    |
| --------------------------------- | ---- | --------------------------------- | ---- | --------------------------------- | ---- | --------------------------------- | ---- |

| <span style="color:red;">3</span> | 1    | <span style="color:red;">4</span> | 2    | <span style="color:red;">7</span> | 6    | <span style="color:red;">8</span> | 5    |
| --------------------------------- | ---- | --------------------------------- | ---- | --------------------------------- | ---- | --------------------------------- | ---- |

**2그룹**

| 3    | <span style="color:red;">1</span> | 4    | <span style="color:red;">2</span> | 7    | <span style="color:red;">6</span> | 8    | <span style="color:red;">5</span> |
| ---- | --------------------------------- | ---- | --------------------------------- | ---- | --------------------------------- | ---- | --------------------------------- |

| 3    | <span style="color:red;">1</span> | 4    | <span style="color:red;">2</span> | 7    | <span style="color:red;">5</span> | 8    | <span style="color:red;">6</span> |
| ---- | --------------------------------- | ---- | --------------------------------- | ---- | --------------------------------- | ---- | --------------------------------- |

이렇게 해서 얻은 배열은 좀 더 정렬된 상태에 가까워진다. 마지막으로 '1-정렬'을 적용하면 정렬을 마치게 된다.



위 표를 통해 셸 정렬의 전체흐름을 나타냈다. 셸 정렬 과정에서 수행하는 각각의 정렬을 'H-정렬'이라고 부른다.



정렬되지 않은 상태의 배열에 대해 단순 삽입 정렬을 그냥 적용하는 것이 아니라 '4-정렬', '2-정렬' 로 조금이라도 정렬이 된 상태에 가까운 배열로 만들어 놓은 다음에 마지막으로 단순 삽입 정렬을 수행하여 정렬을 마친다.

이렇게 여러개의 그룹으로 나누어 정렬하는 이유는 단순 삽입 정렬의 장점은 살리고 단점은 보완하기 위해서이다.



정렬해야하는 횟수는 늘지만 전체적으로는 요소 이동의 횟수가 줄어들어 효율적인 정렬을 할 수 있다.



셸 정렬 프로그램 참조.

증분 값 (h값) 의 선택

앞에서는 h값을 아래처럼 변화시켰다.

h= 4,2,1



h값은 n부터 감소시켜 마지막에 1이 되면 된다. 그러면 h값을 어떤수열로 감소시켜야 좀 더 효율적인 정렬을 할 수 있을까?

아래의 배열을 통해 앞에서 했던 배열을 그룹으로 나누는 과정을 다시 살펴보자.

a.

| 8    | 1    | 4    | 2    | 7    | 6    | 3    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |



b.

| <span style="color:red">8</span> | <span style="color:red">7</span> |
| -------------------------------- | -------------------------------- |
| 1                                | 6                                |
| <span style="color:red">4</span> | <span style="color:red">3</span> |
| 2                                | 5                                |



c.

| <span style="color:red">7</span> | <span style="color:red">3</span> | <span style="color:red">8</span> | <span style="color:red">4</span> |
| -------------------------------- | -------------------------------- | -------------------------------- | -------------------------------- |
| 1                                | 2                                | 6                                | 5                                |

여기서 a는 학생 8명의 점수를 나타내고 있다고 가정하자. 

먼저 b는 학생을 2명씩 4개의 그룹으로 나누어 정렬하고 c처럼 학생을 4명씩 2개의 그룹으로 나누어 다시 정렬한다. 

여기서 b의 2개의 그룹을 각각 합치면 c그룹이 된다. 즉 '빨강 그룹과' '일반 그룹' 은 서로 섞이지 않는다.

그런데 이렇게 그룹이 섞이지 않으면 c를 합쳤을 때 다시 처음 단계인 a와 동일한 상태가 된다.



그러면 다시 a의 학생을 정렬하는것과 같아서 기껏 그룹을 나누었음에도 정렬 알고리즘이 동작하지 않는다.



이를 해결하기 위해서 h값이 서로 배수가 되지 않도록 해야한다. 이렇게 하면 요소가 충분히 섞여 효율적인 기대를 할 수 있다.



다음의 수열을 사용하면 셸 정렬 알고리즘을 간단한게 만들 수 있을 뿐만 아니라 효율적인 결과도 얻을 수 있다.



h =  ..., 121, 40, 13, 4, 1



이 수열을 거꾸로 살펴보면 1부터 시작해서 3배한 값에 1을 더하는 수열이라는 것을 알 수 있다.

또 h의 초깃값은 너무 크면 효과가 없기 때문에 배열의 요솟수 n을 9로 나눈 값을 넘지 않도록 정해야 한다.



**문제3. 셸정렬을 위의 수열의 법칙을 이용하여 수정하라.**