#시간복잡도란
작동하는 알고리즘의 수행시간을 정량화 한것.


<h3>시간 복잡도 표기법</h3>
1.Big-O:Worst case를 나타내는 표기법.<br>
2.Big-Omega: Best case를 나타내는 표기법.<br>
3.Big-Theta:Average case를 나태는 표기법.<br>
일반적으로 빅-오 표기법을 사용한다.

<h3>시간 복잡도 계산</h3>
Big-O : O(N)<br>
알고리즘의 시간복잡도는 연산의 횟수 T를 구하는 방법이 주로 쓰인다.<BR>
통산적으로 1억번의 연산당 1초의 시간이 걸린다고 간주하여 알고리즘의 수행시간을 예측한다.

<h3>시간 복잡도 종류</h3>
상수형:시간계산도 O(1)이다. ex) 길이가 N인 배열에서 M번째 배열값을 출력.<br>
로그형:시간계산도 O(logN)이며 N개의 정렬된 수열에서 이분탐색 또는 우선순위 큐에서는 원소 삽입,삭제연산.<br>
선형:시간계산도 O(N)이며 정렬되지 않은 길이가 N인 배열에서 가장 작은 수 탐색.(단일 포문)
선형로그형: O(NlogN)이며 힙 정렬, 병합정렬.
2차형:(N^2): 버블정렬, 삽입정렬, 퀵 정렬(2중 포문)
3차형:(N^3) 플로이드-위셜 알고리즘(3중포문)
지수형:2^N 번호가 매겨진 N개의 동전을 던졌을때 나오는 경우의 수
팩토리얼형: 1부터 N까지의 숫자를 나열할 수 있는 모든 방법을 출력하는 함수.

일반적으로 시간복잡도는 계산를 때고 최고차항만을 나타낸다. 예를 들어 O(2N^2+N)일경우 O(N^2)으로 표기.
<hr>

#공간복잡도
알고리즘의 메모리 사용량에 대한 분석결과로, 알고리즘 문제를 해결하기 위해서 사용하는 메모리의 크기를 말한다.<BR>
S(p) = c + Sp(n) <br>
총 공간 요구 = 고정 공간 여부 + 가변 공간 여부<br>


```
int sum(int a[], int n)
{
  int x = 0;		
  for(int i = 0; i < n; i++) {
    x  = x + a[i];
  }
  return(x);
}
```
int arr[n] : 4*n byte<br>
int n: 4 bytes <br>
int x: 4 bytes <br>
int i: 4bytes <br>
총 4n+12의 공간복잡도를 차지하며 빅오표기법으로 나타내면  O(n)이다.
<hr>



