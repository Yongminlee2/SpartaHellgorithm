
##### 문제1) 아래의 블로그를 참조하고 어떤 방식을 취하는게 왜 좋을지 작성해주세요.

https://yaboong.github.io/java/2018/06/09/java-garbage-collection/

저는 제가 작성한 for문을 이용해서 배열의 각 인덱스별 값을 0 또는 null으로 초기화 하였는대
    	for(E a:stk) { 
    		stk[i] = null;
    		i++;
    	}
블로그를 읽고 이방식이 저는 낫다고 생각합니다.
이유는 자바에선 jvm 으로 gc 가 자동적으로 이루어지는대
처음에 생성햇을 당시에 heap 영역에 메모리가 할당되는대 새로운 값을 넣어주면
기존에 있던 값은 unreachable 오브젝트가 되고 그다음에 jvm 에서
sweep 이 바로 일어나서 제거해주기 때문에 새로 값을 할당해서 기존값을 unreachable 상태로
만드는게 낫다고 판단됩니다.

-------------------------------------------------------------------------------------------------------


##### 문제2.유클리드 호제법

두 정수의 최대공약수(greatest common divisor)를 재귀적으로 구하는 방법이다. 유클리드 호제법에 대해 자세한 설명과 코드 구현하라.

에우클레이데스 (유클리드) 라는 기원전 300년경 고대 그리스의 수학자가 집필한 13권중 7권에 있다.

유클리드 호제법은 두 양의 정수의 최대공약수를 구하는 알고리즘이다.
유클리드에 의해 기원전 300년경에 발견된 가장 오래된 알고리즘. (기원전 300년에 똑똑이가 잇었네)

mod 연산 : 큰수를 작은수로 나눠 나머지를 구한다

유클리드 호제법 : mod연산을 0이 나올떄까지 반복.
소인수 분해로 하나하나 다구해서 하면 큰수가나올떈 기하급수적으로 커져서 너무 오래걸리는대

유클리드호제법으로 작은수에서 큰수로 나누고 나눈값으로 또 나누면 이진트리처럼 큰수로 계속 작아져서
몇회전을 안하고도 값을 구하기가 용이하다.

코드 euclid. java에 기술



##### 문제3. 재귀 메서드를 호출하지 않고 factorial 메서드를 작성하라.

 

#### 재귀 알고리즘의 분석

재귀 알고리즘을 분석하기 위한 하향식(top down) 분석과 상향식(bottom up) 분석을 Recur 클래스를 통해 알아본다.

recur 메서드는 factorial 메서드나 gcd 메서드와 달리 메서드 안에서 재귀 호출을 2회 실행한다. 이처럼 재귀 호출을 여러 회 실행하는 메서드를 순수하게(genuinely) 재귀적이라고 하며, 실제 동작은 매우 복잡하다.



이런 복잡한 구조를 가진 재귀 메서드는 전략적으로 분석해야한다.

여기서는 recur 메서드를 하향식과 상향식의 두방법으로 분석한다.



##### 하향식 분석 [패키지에 topdown.png있음]

매개변수 n으로 4를 전달하면 recur 메서드는 아래 과정을 순서대로 실행한다.

```
1. recur(3)을 실행한다.
2. 4를 출력한다.
3. recur(2)를 실행한다.
```

물론 (2)에서 4를 출력하는것은 (1)의 recur(3)가 실행이 완료된 이후이다.

![image-20211114212822127](../../assets/images/Readme/image-20211114212822127.png)

이처럼 가장 위쪽에 위치한 상자의 메서드 호출부터 시작해 계단식으로 자세히 조사하는 분석 기법을 하향식 분석(top-down analysis)이라고 한다.

그런데 이 그림 안에는 recur(1), recur(2)의 호출이 여러번 있다. 

꼭대기(top)부터 분석하면 이렇게 같은 메서드의 호출이 여러 번 나올 수 있기 때문에 '하향식 분석이 반드시 효율적이다' 라고 말할 수는 없다.



##### 상향식 분석

위쪽부터 분석하는 하향식 분석과는 대조적으로 아래쪽부터 쌓아 올리며 분석하는 방법이 상향식 분석 (bottom-up analysis)이다. recur 메서드는 n이 양수일 때만 실행하므로 먼저 recur(1)을 생각해보겠다.

```
1. recur(0)을 실행한다.
2. 1을 출력한다.
3. recur(-1)을 실행한다.
```

여기서 (1)의 recur(0)과 (3)의 recur(-1)은 출력할 내용이 없다. 따라서 (2)의 1만 출력한다. 그럼 recur(2)에 대해 생각해 보자.

```
1. recur(1)을 실행한다.
2. 2를 출력한다.
3. recur(0)을 실행한다.
```

(1)의 recur(1)은 1을 출력하고 (3)의 recur(0)은 출력할 내용이 없다. 전체 과정을 거치면 1과 2가 출력이 된다. 이작업을 recur(4)까지 쌓아 올려 설명한 내용은 다음과 같다.

```
recur(-1) 	: 아무것도 하지 않음
recur(0) 	: 아무것도 하지않음
recur(1) 	: recur(0) 1 recur(-1) 	-> 1
recur(2) 	: recur(1) 2 recur(0) 	-> 1 2
recur(3)  	: recur(2) 3 recur(1) 	-> 1 2 3 1
recur(4)	: recur(3) 4 recur(2) 	-> 1 2 3 1 4 1 2
```



#### 문제4. 아래의 recur2 메서드를 보고 하향식 분석과 상향식 분석을 수행하라. [설명과 사진 첨부해주세요]

```
static void recur2(int n) {
	if ( n > 0 ) {
		recur2(n-2);
		System.out.prinlnt(n);
		recur2(n-1);
	}
}
```



#### 문제5. 위 Recur 클래스의 recur 메소드를 재귀호출을 사용하지않고, 앞서 배운 Stack을 이용하여 구현하라.

