
##### 문제1) 아래의 블로그를 참조하고 어떤 방식을 취하는게 왜 좋을지 작성해주세요.

https://yaboong.github.io/java/2018/06/09/java-garbage-collection/

저는 제가 작성한 for문을 이용해서 배열의 각 인덱스별 값을 0 또는 null으로 초기화 하였는대
    	for(E a:stk) { 
    		stk[i] = null;
    		i++;
    	}
블로그를 읽고 이방식이 저는 낫다고 생각합니다.
이유는 자바에선 jvm 으로 gc 가 자동적으로 이루어지는대
처음에 생성햇을 당시에 heap 영역에 메모리가 할당되는대 새로운 값을 넣어주면
기존에 있던 값은 unreachable 오브젝트가 되고 그다음에 jvm 에서
sweep 이 바로 일어나서 제거해주기 때문에 새로 값을 할당해서 기존값을 unreachable 상태로
만드는게 낫다고 판단됩니다.
라고 생각했는대 for 문의 반복이 수없이 많아진다면 이펙이 발생해서
for문으로 재정의 하는것보다 객체를 생성하여 gc를 기다리는게 더 유용한것같습니다
어차피 gc는 jvm이 알아서 메모리 관리해주니 별도의 시간복잡도를 잡아먹진않으니..

-------------------------------------------------------------------------------------------------------


##### 문제2.유클리드 호제법

두 정수의 최대공약수(greatest common divisor)를 재귀적으로 구하는 방법이다. 유클리드 호제법에 대해 자세한 설명과 코드 구현하라.

에우클레이데스 (유클리드) 라는 기원전 300년경 고대 그리스의 수학자가 집필한 13권중 7권에 있다.

유클리드 호제법은 두 양의 정수의 최대공약수를 구하는 알고리즘이다.
유클리드에 의해 기원전 300년경에 발견된 가장 오래된 알고리즘. (기원전 300년에 똑똑이가 잇었네)

mod 연산 : 큰수를 작은수로 나눠 나머지를 구한다

유클리드 호제법 : mod연산을 0이 나올떄까지 반복.
소인수 분해로 하나하나 다구해서 하면 큰수가나올떈 기하급수적으로 커져서 너무 오래걸리는대

유클리드호제법으로 작은수에서 큰수로 나누고 나눈값으로 또 나누면 이진트리처럼 큰수로 계속 작아져서
몇회전을 안하고도 값을 구하기가 용이하다.

코드 euclid. java에 기술



##### 문제3. 재귀 메서드를 호출하지 않고 factorial 메서드를 작성하라.
factorial.java -- factorial2 참조
 

#### 문제4. 아래의 recur2 메서드를 보고 하향식 분석과 상향식 분석을 수행하라. [설명과 사진 첨부해주세요]

```
static void recur2(int n) {
	if ( n > 0 ) {
		recur2(n-2);
		System.out.prinlnt(n);
		recur2(n-1);
	}
}
```
-- 하향식.jpg 상향식.jpg 참조


#### 문제5. 위 Recur 클래스의 recur 메소드를 재귀호출을 사용하지않고, 앞서 배운 Stack을 이용하여 구현하라.
-- recur.java 참조
