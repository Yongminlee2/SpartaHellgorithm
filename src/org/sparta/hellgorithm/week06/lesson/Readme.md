12월 ~ 1월은 연말 연초 분위기상 많은 진도를 나가지 않겠습니다.



#### 정렬

**정렬(sorting)은 이름, 학번, 키 등 핵심 항목(key)의 대소 관계에 따라 데이터 집합을 일정한 순서로 줄지어 늘어서도록 바꾸는 작업을 말한다.**

이 알고리즘을 이용해 데이터를 정렬하면 검색을 더 쉽게 할 수 있다.

만약 사전에 실린 수십만 개의 단어가 알파벳이나 가나다순으로 정렬되어 있지 않으면 원하는 단어를 찾기가 어려울 것이다.

**키 값이 작은 데이터를 앞쪽에 놓으면 오름차순(ascending Order), 그 반대로 키 값이 큰 데이터를 앞 쪽에 놓으면 내림차순(descending Order) 정렬이라고 부른다.**



**정렬에는 안정된(stable) 알고리즘과 그렇지 않은 알고리즘으로 나눌 수 있다.**

**안정된 정렬이란 같은 값의 키를 가진 요소의 순서가 정렬전후에도 유지되는 것을 말한다.**



30장의 카드를 한 줄로 늘어놓을 수 있는 책상에서 트럼프 카드를 정렬한다고 가정해보자.

만약 카드가 30장 이하라면 모든 카드를 책상에 늘어놓고 한 번에 훑어보면서 작업할 수 있지만 카드가 500장이라면 책상에 모든 카드를 늘어놓을 수 없기 때문에 큰 책상을 따로 마련해야 한다.

정렬 알고리즘도 하나의 배열에서 작업할 수 있는 경우에는 내부 정렬(Internal sorting)을 사용하고, 하나의 배열에서 작업할 수 없는 경우에는 외부 정렬(external sorting)을 사용한다.



**내부 정렬: 정렬할 모든 데이터를 하나의 배열에 저장할 수 있는 경우에 사용하는 알고리즘**

**외부 정렬: 정렬할 데이터가 너무 많아서 하나의 배열에 저장할 수 없는 경우에 사용하는 알고리즘**



**정렬 알고리즘의 핵심 요소는 교환, 선택, 삽입이며 대부분의 정렬 알고리즘은 이 세 가지 요소를 응용한 것이다.**



#### 버블 정렬-1 [BubbleSort1 클래스]

버블 정렬은 이웃한 두 요소의 대소 관계를 비교하여 교환을 반복한다.

아래의 배열을 이요해 버블 정렬에 대해 알아보겠다.

| 6    | 4    | 3    | 7    | 1    | 9    | 8    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |

먼저 끝에 있는 두 요소 9와 8부터 시작한다. 이때 오름차순으로 배열을 정리하고자 한다면

왼쪽의 값이 오른쪽의 값보다 작아야 한다. 따라서 9와 8을 교환하면 배열은 아래와 같은 상태가 된다.

| 6    | 4    | 3    | 7    | 1    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |

그런 다음 뒤쪽에서 2, 3번째 요소(1,8)를 비교한다. 1은 8보다 작으므로 교환할 필요가 없다.

이렇게 이웃한 요소를 비교하고 교환하는 작업을 첫 번째 요소까지 계속하면 다음 그림과 같이 된다. 

| 6    | 4    | 7    | 3    | 1    | <span style="color:red;">9</span> | <span style="color:red;">8</span> |
| ---- | ---- | ---- | ---- | ---- | --------------------------------- | --------------------------------- |

| 6    | 4    | 3    | 7    | <span style="color:red;">1</span> | <span style="color:red;">8</span> | 9    |
| ---- | ---- | ---- | ---- | --------------------------------- | --------------------------------- | ---- |

| 6    | 4    | 3    | <span style="color:red;">7</span> | <span style="color:red;">1</span> | 8    | 9    |
| ---- | ---- | ---- | --------------------------------- | --------------------------------- | ---- | ---- |

| 6    | 4    | <span style="color:red;">3</span> | <span style="color:red;">1</span> | 7    | 8    | 9    |
| ---- | ---- | --------------------------------- | --------------------------------- | ---- | ---- | ---- |

| 6    | <span style="color:red;">4</span> | <span style="color:red;">1</span> | 3    | 7    | 8    | 9    |
| ---- | --------------------------------- | --------------------------------- | ---- | ---- | ---- | ---- |

| <span style="color:red;">6</span> | <span style="color:red;">1</span> | 3    | 4    | 7    | 8    | 9    |
| --------------------------------- | --------------------------------- | ---- | ---- | ---- | ---- | ---- |

| 1    | 6    | 4    | 3    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |

요소의 개수가 n개인 배열에서 n-1회 비교, 교환을 하고 나면 가장 작은 요소가 맨 처음으로 이동한다.

그리고 이런 일련의 과정(비교, 교환 작업)을 패스(pass)라고 한다.



이런식으로 배열의 2번째,3번째 요소에 대해 비교 교환을 하는 패스를 수행하고나면 정렬이 끝난다.

모든 정렬이 끝나려면 n-1회의 패스가 수행 되어야한다.



##### 문제1. 버블 정렬의 각 패스에서 비교, 교환은 처음(왼쪽) 부터 수행해도된다. 그렇게 수정한 프로그램을 작성하라.



##### 문제2. 비교 교환 과정을 자세히 출력하면서 버블 정렬하는 프로그램을 작성하라. 비교하는 두 요소 사이에 교환을 수행하면'+', 수행하지 않으면 '-'를 출력하고 정렬을 마치면 비교횟수와 교환 횟수를 출력하라.



#### 버블정렬-2  - 개선편

다음 표를 보고 비교, 교환 작업을 어떻게 개선 할 수 있을지 살펴보자.



| 1    | 3    | 6    | 4    | 7    | <span style="color:red;">8</span> | <span style="color:red;">9</span> |
| ---- | ---- | ---- | ---- | ---- | --------------------------------- | --------------------------------- |

| 1    | 3    | 6    | 4    | <span style="color:red;">7</span> | <span style="color:red;">8</span> | 9    |
| ---- | ---- | ---- | ---- | --------------------------------- | --------------------------------- | ---- |

| 1    | 3    | 6    | <span style="color:red;">4</span> | <span style="color:red;">7</span> | 8    | 9    |
| ---- | ---- | ---- | --------------------------------- | --------------------------------- | ---- | ---- |

| 1    | 3    | <span style="color:red;">6</span> | <span style="color:red;">4</span> | 7    | 8    | 9    |
| ---- | ---- | --------------------------------- | --------------------------------- | ---- | ---- | ---- |

| 1    | 3    | 4    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |

--------------------------------------------------버블 정렬의 세 번째 패스 [ n-3 회 ]-----------------------------------------

| 1    | 3    | 4    | 6    | 7    | <span style="color:red;">8</span> | <span style="color:red;">9</span> |
| ---- | ---- | ---- | ---- | ---- | --------------------------------- | --------------------------------- |

| 1    | 3    | 4    | 6    | <span style="color:red;">7</span> | <span style="color:red;">8</span> | 9    |
| ---- | ---- | ---- | ---- | --------------------------------- | --------------------------------- | ---- |

| 1    | 3    | 4    | <span style="color:red;">6</span> | <span style="color:red;">7</span> | 8    | 9    |
| ---- | ---- | ---- | --------------------------------- | --------------------------------- | ---- | ---- |

| 1    | 3    | 4    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |

--------------------------------------------------버블 정렬의 네 번째 패스 [ n-4 회 ]-----------------------------------------

위 표를 보면 네번째 페스에서는 한번의 교환이 이루어지지 않는다.

이미 배열이 정렬을 마친 상태이기 떄문이다.

즉, 어떤 패스에서 요소의 교환 횟수가 0이면 더이상 정렬할 요소가 없다는 뜻이기 때문에 정렬 작업을 멈추면 된다.

버블 정렬 메서드 버전2는 이런 '멈춤'을 개선한 것이다.



##### 문제3.

버블 정렬 메서드 버전2을 문제2처럼 교환 과정을 자세히 출력하는 프로그램으로 수정하라.



#### 버블정렬-3

다시 새로운 배열 ({1,3,9,4,7,8,6})에 대해서 버블 정렬을 수행해보자.

| 1    | 3    | 9    | 4    | 7    | <span style="color:red;">8</span> | <span style="color:red;">6</span> |
| ---- | ---- | ---- | ---- | ---- | --------------------------------- | --------------------------------- |

| 1    | 3    | 9    | 4    | <span style="color:red;">7</span> | <span style="color:red;">6</span> | 8    |
| ---- | ---- | ---- | ---- | --------------------------------- | --------------------------------- | ---- |

| 1    | 3    | 9    | <span style="color:red;">4</span> | <span style="color:red;">6</span> | 7    | 8    |
| ---- | ---- | ---- | --------------------------------- | --------------------------------- | ---- | ---- |

| 1    | 3    | <span style="color:red;">9</span> | <span style="color:red;">4</span> | 6    | 7    | 8    |
| ---- | ---- | --------------------------------- | --------------------------------- | ---- | ---- | ---- |

| 1    | <span style="color:red;">3</span> | <span style="color:red;">4</span> | 9    | 6    | 7    | 8    |
| ---- | --------------------------------- | --------------------------------- | ---- | ---- | ---- | ---- |

| <span style="color:red;">1</span> | <span style="color:red;">3</span> | 4    | 9    | 6    | 7    | 8    |
| --------------------------------- | --------------------------------- | ---- | ---- | ---- | ---- | ---- |

| 1    | 3    | 4    | 9    | 6    | 7    | 8    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |

교환을 마치고 난 이후의 세 요소({1,3,4})는 정렬된 상태이다. 이렇게 각각의 패스에서 비교, 교환을 하다가 어떤 시점 이후에 교환이 수행 되지 않는다면 그보다 앞쪽의 요소는 이미 정렬을 마친 상태라고 생각하면 된다.

따라서 두번째 패스는 첫 요소를 제외한 6개 요소가아니라 4개의 요소에 대해서 비교, 교환을 수행하면된다.

| 1    | 3    | 4    | 9    | 6    | <span style="color:red;">7</span> | <span style="color:red;">8</span> |
| ---- | ---- | ---- | ---- | ---- | --------------------------------- | --------------------------------- |

| 1    | 3    | 4    | 9    | <span style="color:red;">6</span> | <span style="color:red;">7</span> | 8    |
| ---- | ---- | ---- | ---- | --------------------------------- | --------------------------------- | ---- |

| 1    | 3    | 4    | <span style="color:red;">9</span> | <span style="color:red;">6</span> | 7    | 8    |
| ---- | ---- | ---- | --------------------------------- | --------------------------------- | ---- | ---- |

| 1    | 3    | 4    | 6    | 9    | 7    | 8    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |

버블정렬 3 메소드를 참조할것.

last는 각 패스에서 마지막으로 교환한 두 요소 가운데 오른쪽 요소의 인덱스를 저장하기 위한 변수이다. 교환을 수행할 때마다 오른쪽 요소의 인덱스 값을 last에 저장한다. 하나의 패스를 마쳤을 때 last 값을 k에 대입하여 다음에 수행할 패스의 범위를 제한한다. 그러면 다음 패스에서 마지막으로 비교할 두 요소는 a[k]와 a[k+1]이 된다. 이떄 bubbleSort 메서드의 시작 부분에서 k값을 0으로 초기화 하는 이유는 첫 번째 패스에서는 모든 요소를 검사해야 하기 때문이다.



##### 문제 4. 버블정렬 3메소드도 교환 과정을 자세히 출력하는 프로그램을 작성하라.



##### 문제 5.  다음의 배열을 정렬한다고 가정한다.

| 9    | 1    | 3    | 4    | 6    | 7    | 8    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |

이 배열은 두 번째 요소부터는 정렬은 되어 있지만 버전3의 버블 정렬 알고리즘을 사용해도 빠른 시간안에 정렬 작업을 마칠 수는 없다. 왜냐하면 맨 앞에 있는 요소의 값(9)는 1회의 패스를 거쳐도 한 칸씩만 뒤로 옮겨지기 때문이다. 그래서 홀수 번째의 패스는 가장 작은 요소를 맨 앞으로 옮기고 한 칸씩만 뒤로 옮겨지기 때문이다. 그래서 홀 수 번째의 패스는 가장 작은 요소를 맨 앞으로 옮기고 짝수 번째 패스는 가장 큰 요소를 맨 뒤로 옮기는 방식을 사용하면 정렬을 더 적은 횟수로 비교할 수 있다.

버블정렬 3의 메소드를 개선하여 양방향 버블정렬[칵테일 정렬, 세이커정렬] 을 수행하는 프로그램을 작성하라.

